## Extended Correction Note
While conducting subsequent experiments and analyses we became aware of an error in Figure 7, panel J in our paper “[Dynamic and reversible remapping of network representations in an unchanging environment.](https://www.cell.com/neuron/pdf/S0896-6273(21)00504-3.pdf)” This error is described briefly in the correction note in the HTML and PDF version of our paper, but we include here a more detailed description of what occurred.

A very difficult to notice bug in our code, described below, caused our null distribution (constructed by random “shuffles”) to be miscalculated. Importantly, this error is confined to Figure 7J and does not impact the qualitative result of that panel — all effects reported as statistically significant in our original paper remain statistically significant. After a careful review of our paper, no revisions were needed to our interpretation or discussion of the results. However, the quantitative effect sizes were different, as shown below, and resulted in the need to issue a correction (see paper linked above) to show the appropriate distribution in Figure 7J.

Below, we show the original panel (left) and the corrected panel (right). Importantly, the “manifold misalignment scores” are normalized such that values greater than one are 
not statistically significant using a threshold of p = 0.025 (left tail of a two-sided shuffle distribution). While the distribution has shifted to the right in the corrected 
plot, you can see that every session is below this threshold and thus the manifolds measured in each case are significantly more aligned than chance.

Below we reproduce our original and corrected code to illustrate the nature of the error. Our intention was to shuffle our data by applying a random rotation — this is done by
matrix multiplying the data (below, a matrix X) with a random orthogonal matrix. The orthogonal matrix was generated by performing QR factorization on a Gaussian random matrix,
which is accomplished by: `np.linalg.qr(np.random.randn(n, n))`. The problem is that the QR factorization returns a tuple of two matrices — the first is orthogonal, the second
is upper triangular — and we did not “throw away” the second matrix. Due to the default behavior of numpy, performing the matrix multiplication  `X @ np.linalg.qr(np.random.randn(n, n))`,
causes the result to stack the pair of matrices into a 3D array with shape = (2 x m x n) and then broadcast the matrix multiply operation along the first dimension.
On the following line, we compute the root-mean-squared-error with another matrix `Y`. Unfortunately, numpy broadcasts again so that the subtraction produces a (2 x m x n) array.
Then, the function `np.mean(...)` takes the average overall error — both for the intended orthogonal matrix as well as the unintended upper-triangular matrix.

### Original Code
```
import numpy as np
X_shuff = X @ np.linalg.qr(np.random.randn(n, n))
shuffled_rmse = np.sqrt(np.mean((X_shuff - Y) ** 2))
```

### Corrected Code
```
import numpy as np
X_shuff = X @ np.linalg.qr(np.random.randn(n, n))[0] # <--note that indexing solves the error
shuffled_rmse = np.sqrt(np.mean((X_shuff - Y) ** 2))
```

See lines 208 - 214 of [Fig7_FigS7_manifolds/summary_figs.py](https://github.com/GiocomoLab/Low_etal_2021/blob/main/Fig7_FigS7_manifolds/summary_figs.py) for the corrected code in context.

Typically, when one makes an error that unexpectedly changes the shape of an array, it causes a fatal dimension mismatch error that causes the code to halt and then can be
corrected. Failing that, if the variable is used downstream for other tasks (e.g. plotting), the erroneous shape may be noticed. Unfortunately here, the error entered our
program on one line and silently left on the very next line (the variable `X_shuff` was never used again). This is what made the error very difficult to catch.

We have corrected this error in the PDF and HTML versions of the paper and made the necessary adjustments to this code base.
